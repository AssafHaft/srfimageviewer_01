<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Reception TV Image Viewer</title>
    <meta name="color-scheme" content="dark light" />
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: #000;
        color: #fff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Viewer fills the screen */
      #viewer {
        position: fixed;
        top: 0; right: 0; bottom: 0; left: 0; /* avoid 'inset' for older TVs */
        background: #000;
        overflow: hidden;
        z-index: 1;
      }
      .layer {
        position: absolute;
        top: 0; right: 0; bottom: 0; left: 0; /* avoid 'inset' for older TVs */
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 800ms linear; /* no CSS variables for older TVs */
        will-change: opacity;
      }
      .layer.visible { opacity: 1; }
      .layer img {
        width: 100%;
        height: 100%;
        object-fit: contain; /* Avoid cropping; change to 'cover' if preferred */
        background: #000;
      }

      /* Minimal control bar */
      #controls {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 8px 12px;
        background: rgba(0,0,0,0.5);
        /* avoid backdrop-filter for broader TV support */
        color: #fff;
        font-size: 14px;
        transition: transform 200ms ease-out, opacity 200ms ease-out;
        z-index: 2;
      }
      #controls.hidden { transform: translateY(100%); opacity: 0; }
      #controls button, #controls select, #controls input[type="number"] {
        background: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 6px 10px;
      }
      #controls button { cursor: pointer; }
      #status { margin-left: auto; opacity: 0.8; }
      #help { font-size: 12px; opacity: 0.8; }

      /* Management Panel */
      #manageBtn {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 100;
        background: rgba(0,0,0,0.8);
        color: #fff;
        border: 1px solid #555;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        transition: background 200ms;
      }
      #manageBtn:hover { background: rgba(0,0,0,0.95); }
      #managePanel {
        position: fixed;
        top: 0;
        right: 0;
        width: 400px;
        max-width: 90vw;
        height: 100vh;
        background: rgba(0,0,0,0.95);
        border-left: 1px solid #333;
        z-index: 99;
        transform: translateX(100%);
        transition: transform 300ms ease-out;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }
      #managePanel.open { transform: translateX(0); }
      #managePanel h2 {
        margin: 0 0 20px 0;
        font-size: 20px;
        border-bottom: 1px solid #333;
        padding-bottom: 10px;
      }
      #managePanel .section {
        margin-bottom: 24px;
      }
      #managePanel label {
        display: block;
        margin-bottom: 8px;
        font-size: 13px;
        opacity: 0.9;
      }
      #managePanel input[type="text"],
      #managePanel input[type="password"],
      #managePanel input[type="file"] {
        width: 100%;
        padding: 8px;
        background: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 4px;
        box-sizing: border-box;
        font-size: 13px;
      }
      #managePanel input[type="file"] {
        padding: 4px;
        cursor: pointer;
      }
      #managePanel button {
        width: 100%;
        padding: 10px;
        background: #1a1a1a;
        color: #fff;
        border: 1px solid #444;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 8px;
        transition: background 200ms;
      }
      #managePanel button:hover { background: #2a2a2a; }
      #managePanel button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #managePanel button.danger {
        background: #4a1a1a;
        border-color: #733;
      }
      #managePanel button.danger:hover { background: #5a2a2a; }
      #managePanel .image-list {
        margin-top: 12px;
      }
      #managePanel .image-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        background: #111;
        border: 1px solid #222;
        border-radius: 4px;
        margin-bottom: 8px;
      }
      #managePanel .image-item img {
        width: 60px;
        height: 60px;
        object-fit: cover;
        border-radius: 4px;
        border: 1px solid #333;
      }
      #managePanel .image-item .info {
        flex: 1;
        min-width: 0;
      }
      #managePanel .image-item .name {
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 4px;
      }
      #managePanel .image-item .size {
        font-size: 11px;
        opacity: 0.6;
      }
      #managePanel .image-item button {
        width: auto;
        padding: 6px 12px;
        margin: 0;
        font-size: 12px;
      }
      #managePanel .message {
        padding: 10px;
        border-radius: 4px;
        margin-top: 12px;
        font-size: 13px;
      }
      #managePanel .message.success {
        background: rgba(0,100,0,0.3);
        border: 1px solid #0a0;
        color: #afa;
      }
      #managePanel .message.error {
        background: rgba(100,0,0,0.3);
        border: 1px solid #a00;
        color: #faa;
      }
      #managePanel .message.info {
        background: rgba(0,50,100,0.3);
        border: 1px solid #05a;
        color: #aaf;
      }

      a, a:visited { color: #9ad; }

      /* No mouse on TVs; keep controls visible initially */
      @media (hover:hover) and (pointer:fine) {
        #controls.hidden { opacity: 0; }
      }
    </style>
  </head>
  <body>
    <div id="viewer" aria-live="off">
      <div class="layer" id="layerA"><img alt="" /></div>
      <div class="layer" id="layerB"><img alt="" /></div>
    </div>

    <button id="manageBtn" title="Image Management">⚙️ Manage</button>

    <div id="managePanel">
      <h2>Image Management</h2>
      
      <div class="section">
        <label>GitHub Personal Access Token</label>
        <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxx" />
        <button id="saveTokenBtn">Save Token</button>
        <div style="font-size: 11px; opacity: 0.7; margin-top: 8px;">
          Create a token at: <a href="https://github.com/settings/tokens" target="_blank" style="color: #9ad;">github.com/settings/tokens</a><br/>
          Required scopes: <code>repo</code> (full control of private repositories)
        </div>
      </div>

      <div class="section">
        <label>GitHub Repository</label>
        <input type="text" id="githubRepo" placeholder="username/repo-name" />
        <button id="saveRepoBtn">Save Repo</button>
        <div style="font-size: 11px; opacity: 0.7; margin-top: 8px;">
          Format: owner/repository (e.g., yourusername/srfimageviewer_01)
        </div>
      </div>

      <div class="section">
        <label>Upload New Image</label>
        <input type="file" id="fileInput" accept="image/*" multiple />
        <button id="uploadBtn" disabled>Upload Selected</button>
        <div id="uploadStatus"></div>
      </div>

      <div class="section">
        <h3 style="margin: 0 0 12px 0; font-size: 16px;">Current Images</h3>
        <button id="refreshListBtn">Refresh List</button>
        <button id="updateManifestBtn" style="margin-top: 8px;">Update Manifest</button>
        <div id="imageList" class="image-list"></div>
      </div>
    </div>

    <div id="controls" class="hidden" role="group" aria-label="Controls">
      <button id="btnPlayPause" title="Play / Pause">Play</button>
      <button id="btnPrev" title="Previous">Prev</button>
      <button id="btnNext" title="Next">Next</button>
      <label>
        Mode
        <select id="mode">
          <option value="slideshow">Slideshow (all)</option>
          <option value="single">Single image</option>
        </select>
      </label>
      <label>
        Image
        <select id="imageSelect" disabled></select>
      </label>
      <label>
        Duration s
        <input id="duration" type="number" min="2" max="120" step="1" value="8" />
      </label>
      <label>
        Fade ms
        <input id="fade" type="number" min="0" max="5000" step="100" value="800" />
      </label>
      <button id="btnFullscreen" title="Fullscreen">Fullscreen</button>
      <button id="btnRefresh" title="Reload image list">Refresh</button>
      <div id="status" aria-live="polite"></div>
    </div>

    <script>
      (function () {
        var SUPPORTED_EXT = [".jpg",".jpeg",".png",".gif",".webp",".bmp",".svg"]; // svg allowed
        var IMAGES_DIR = "images/";
        var state = {
          list: [],
          index: 0,
          playing: true,
          timer: null,
          fadeMs: 800,
          durationSec: 8,
          mode: 'slideshow', // or 'single'
          lastMouse: Date.now(),
          activeLayer: 'A'
        };

        var layerA = document.getElementById('layerA');
        var layerB = document.getElementById('layerB');
        var imgA = layerA.querySelector('img');
        var imgB = layerB.querySelector('img');
        var controls = document.getElementById('controls');
        var btnPlayPause = document.getElementById('btnPlayPause');
        var btnPrev = document.getElementById('btnPrev');
        var btnNext = document.getElementById('btnNext');
        var btnFullscreen = document.getElementById('btnFullscreen');
        var btnRefresh = document.getElementById('btnRefresh');
        var selMode = document.getElementById('mode');
        var selImage = document.getElementById('imageSelect');
        var inpDuration = document.getElementById('duration');
        var inpFade = document.getElementById('fade');
        var statusEl = document.getElementById('status');

        function saveSettings() {
          try {
            localStorage.setItem('srf_tv_settings', JSON.stringify({
              mode: state.mode,
              durationSec: state.durationSec,
              fadeMs: state.fadeMs,
              selected: state.list[state.index] || null
            }));
          } catch (e) {}
        }
        function loadSettings() {
          try {
            var s = JSON.parse(localStorage.getItem('srf_tv_settings') || 'null');
            if (!s) return;
            if (s.durationSec) inpDuration.value = s.durationSec;
            if (s.fadeMs) inpFade.value = s.fadeMs;
            if (s.mode) selMode.value = s.mode;
          } catch (e) {}
        }

        function setStatus(msg) { statusEl.textContent = msg || ''; }

        function sleep(ms, signal) {
          return new Promise(function(resolve){
            var id = setTimeout(resolve, ms);
            if (signal) signal.addEventListener('abort', function(){ clearTimeout(id); resolve(); });
          });
        }

        function hasImageExt(name) {
          var lower = name.toLowerCase();
          for (var i=0;i<SUPPORTED_EXT.length;i++) {
            var ext = SUPPORTED_EXT[i];
            if (lower.slice(-ext.length) === ext) return true; // avoid endsWith for old TVs
          }
          return false;
        }

        function applyFadeMs(ms) {
          state.fadeMs = ms;
          // Update duration directly for older browsers (no CSS vars)
          layerA.style.transitionDuration = ms + 'ms';
          layerB.style.transitionDuration = ms + 'ms';
        }

        function applyDurationSec(sec) {
          state.durationSec = sec;
        }

        function setMode(mode) {
          state.mode = mode;
          selImage.disabled = mode !== 'single';
          if (mode === 'single') {
            // Freeze on current selection
            pause();
            showIndex(selImage.selectedIndex >= 0 ? selImage.selectedIndex : 0, true);
          } else {
            play();
          }
          saveSettings();
        }

        function absoluteUrl(path) {
          try { return new URL(path, window.location.href).toString(); }
          catch (e) { return path; }
        }

        function currentLayer() { return state.activeLayer === 'A' ? layerA : layerB; }
        function nextLayer() { return state.activeLayer === 'A' ? layerB : layerA; }
        function currentImg() { return state.activeLayer === 'A' ? imgA : imgB; }
        function nextImg() { return state.activeLayer === 'A' ? imgB : imgA; }

        function crossfadeTo(url, instant) {
          return new Promise(function(resolve){
            var cur = currentLayer();
            var nxt = nextLayer();
            var nimg = nextImg();
            var resolved = absoluteUrl(url);

            // Prepare handlers
            var done = false;
            function swap() {
              if (done) return; done = true;
              // Force reflow to apply transition reliably
              void nxt.offsetWidth;
              nxt.classList.add('visible');
              cur.classList.remove('visible');
              state.activeLayer = state.activeLayer === 'A' ? 'B' : 'A';
              resolve();
            }
            function fail() {
              if (done) return; done = true;
              console.warn('Failed to load', resolved);
              setStatus('Failed to load image');
              resolve();
            }

            // Attach events BEFORE setting src
            nimg.onload = swap;
            nimg.onerror = fail;
            try { nimg.decoding = 'async'; } catch (e) {}
            try { nimg.loading = 'eager'; } catch (e) {}
            nimg.src = resolved;

            // If instant, don't wait for load to show the layer
            if (instant) {
              swap();
            } else {
              // Fallback in case 'load' never fires on some TVs
              setTimeout(function(){ if (!done && nimg.complete) swap(); }, 1500);
              setTimeout(function(){ if (!done) swap(); }, Math.max(2500, state.fadeMs + 1200));
            }
          });
        }

        function showIndex(idx, instant) {
          if (!state.list.length) return;
          if (idx < 0) idx = state.list.length - 1;
          if (idx >= state.list.length) idx = 0;
          state.index = idx;
          setStatus((idx+1) + '/' + state.list.length);
          return crossfadeTo(state.list[idx], instant);
        }

        function next() {
          if (!state.list.length) return;
          var idx = (state.index + 1) % state.list.length;
          return showIndex(idx, false);
        }
        function prev() {
          if (!state.list.length) return;
          var idx = (state.index - 1 + state.list.length) % state.list.length;
          return showIndex(idx, false);
        }

        function clearTimer() { if (state.timer) { clearTimeout(state.timer); state.timer = null; } }

        function scheduleNext() {
          clearTimer();
          if (!state.playing) return;
          if (state.mode === 'single') return; // no advance
          if (state.list.length <= 1) return; // nothing to loop
          state.timer = setTimeout(function(){ next().then(scheduleNext); }, Math.max(0, (state.durationSec * 1000)));
        }

        function play() {
          if (!state.list.length) return;
          state.playing = true;
          btnPlayPause.textContent = 'Pause';
          scheduleNext();
        }
        function pause() {
          state.playing = false;
          btnPlayPause.textContent = 'Play';
          clearTimer();
        }

        function togglePlay() { state.playing ? pause() : play(); }

        function populateSelect(list, selectedUrl) {
          selImage.innerHTML = '';
          for (var i=0;i<list.length;i++) {
            var opt = document.createElement('option');
            var url = list[i];
            opt.value = url;
            opt.textContent = url.replace(/^.*\//, '');
            if (selectedUrl && url === selectedUrl) opt.selected = true;
            selImage.appendChild(opt);
          }
        }

        function buildListFromDirectoryIndex(htmlText) {
          try {
            var tmp = document.implementation.createHTMLDocument('dir');
            tmp.documentElement.innerHTML = htmlText;
            var anchors = tmp.querySelectorAll('a[href]');
            var urls = [];
            for (var i=0;i<anchors.length;i++) {
              var href = anchors[i].getAttribute('href');
              if (!href || href.indexOf('?') !== -1) continue;
              if (href.indexOf('..') !== -1) continue;
              if (href.startsWith('/')) continue;
              if (!hasImageExt(href)) continue;
              urls.push(IMAGES_DIR + href);
            }
            // Deduplicate
            var seen = {};
            var unique = [];
            for (var j=0;j<urls.length;j++) if (!seen[urls[j]]) { seen[urls[j]] = true; unique.push(urls[j]); }
            return unique;
          } catch (e) {
            return [];
          }
        }

        function fetchJson(url) {
          return fetch(url, {cache:'no-store'}).then(function(r){ if (!r.ok) throw new Error('HTTP '+r.status); return r.json(); });
        }
        function fetchText(url) {
          return fetch(url, {cache:'no-store'}).then(function(r){ if (!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
        }

        function uniqueFilter(arr) {
          var out = []; var seen = {};
          for (var i=0;i<arr.length;i++) if (!seen[arr[i]]) { seen[arr[i]] = true; out.push(arr[i]); }
          return out;
        }

        function normalizeList(list) {
          var out = [];
          for (var i=0;i<list.length;i++) {
            var v = list[i];
            if (!v) continue;
            if (typeof v === 'string') {
              if (v.indexOf('://') === -1 && !v.startsWith(IMAGES_DIR)) v = IMAGES_DIR + v.replace(/^\/+/, '');
              if (!hasImageExt(v)) continue;
              out.push(v);
            }
          }
          return uniqueFilter(out);
        }

        function loadList() {
          setStatus('Loading images...');
          // Try manifest first with cache busting
          var cacheBuster = '?t=' + Date.now();
          return fetchJson(IMAGES_DIR + 'manifest.json' + cacheBuster)
            .then(function(json){
              var list = normalizeList(json && json.images ? json.images : json);
              if (!list.length) throw new Error('Empty manifest');
              return list;
            })
            .catch(function(){
              // Try to parse directory listing
              return fetchText(IMAGES_DIR).then(function(html){
                var list = buildListFromDirectoryIndex(html);
                if (!list.length) throw new Error('No images found');
                return list;
              });
            })
            .catch(function(){
              setStatus('No images found in "' + IMAGES_DIR + '".');
              return [];
            });
        }

        function initKeyboard() {
          window.addEventListener('keydown', function(e){
            var k = e.key || e.code;
            if (k === ' ' || k === 'Space') { togglePlay(); e.preventDefault(); }
            else if (k === 'ArrowRight') { pause(); next(); }
            else if (k === 'ArrowLeft') { pause(); prev(); }
            else if (k === 'f' || k === 'F') { requestFullscreen(); }
          });
        }

        function requestFullscreen() {
          var el = document.documentElement;
          var fn = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
          if (fn) try { fn.call(el); } catch(e) {}
        }

        function autoHideControls() {
          function show() { controls.classList.remove('hidden'); }
          function hide() { controls.classList.add('hidden'); }
          var hideDelay = 2200;
          function onMove(){
            show();
            state.lastMouse = Date.now();
          }
          window.addEventListener('mousemove', onMove);
          window.addEventListener('touchstart', onMove, {passive:true});
          setInterval(function(){ if (Date.now() - state.lastMouse > hideDelay) hide(); }, 500);
          // Show at start
          show();
          setTimeout(hide, hideDelay);
        }

        function wireControls() {
          btnPlayPause.addEventListener('click', togglePlay);
          btnPrev.addEventListener('click', function(){ pause(); prev(); });
          btnNext.addEventListener('click', function(){ pause(); next(); });
          btnFullscreen.addEventListener('click', requestFullscreen);
          btnRefresh.addEventListener('click', function(){
            pause();
            start(true);
          });
          selMode.addEventListener('change', function(){ setMode(this.value); });
          selImage.addEventListener('change', function(){
            var idx = selImage.selectedIndex;
            if (idx >= 0) { pause(); showIndex(idx, false); saveSettings(); }
          });
          inpDuration.addEventListener('change', function(){ applyDurationSec(Math.max(2, parseInt(this.value,10)||8)); saveSettings(); });
          inpFade.addEventListener('change', function(){ applyFadeMs(Math.max(0, parseInt(this.value,10)||800)); saveSettings(); });
        }

        function start(forceReload) {
          loadSettings();
          applyFadeMs(parseInt(inpFade.value,10)||800);
          applyDurationSec(parseInt(inpDuration.value,10)||8);
          state.playing = true;
          btnPlayPause.textContent = 'Pause';
          setStatus('Loading images...');
          return loadList().then(function(list){
            state.list = list;
            if (!list.length) {
              // Clear images
              imgA.removeAttribute('src');
              imgB.removeAttribute('src');
              layerA.classList.remove('visible');
              layerB.classList.remove('visible');
              btnPlayPause.textContent = 'Play';
              return;
            }
            // Build select
            populateSelect(list);

            // Restore mode and selected if available
            try {
              var s = JSON.parse(localStorage.getItem('srf_tv_settings') || 'null');
              if (s && s.selected) {
                var restoredIndex = list.indexOf(s.selected);
                if (restoredIndex >= 0) selImage.selectedIndex = restoredIndex;
              }
            } catch (e) {}

            // Initial show instantly to avoid black flash
            state.activeLayer = 'A';
            layerB.classList.remove('visible');
            layerA.classList.add('visible');
            return showIndex(selMode.value === 'single' && selImage.selectedIndex >= 0 ? selImage.selectedIndex : 0, true).then(function(){
              if (selMode.value === 'single') { setMode('single'); }
              else { setMode('slideshow'); play(); }
            });
          }).catch(function(err){
            console.warn(err);
            setStatus('Error loading images');
          });
        }

        // Expose start function globally for management panel
        window.refreshViewer = function() {
          pause();
          start(true);
        };

        // Boot
        initKeyboard();
        wireControls();
        autoHideControls();
        start();
      })();

      // Management Panel
      (function() {
        var manageBtn = document.getElementById('manageBtn');
        var managePanel = document.getElementById('managePanel');
        var githubTokenInput = document.getElementById('githubToken');
        var githubRepoInput = document.getElementById('githubRepo');
        var saveTokenBtn = document.getElementById('saveTokenBtn');
        var saveRepoBtn = document.getElementById('saveRepoBtn');
        var fileInput = document.getElementById('fileInput');
        var uploadBtn = document.getElementById('uploadBtn');
        var uploadStatus = document.getElementById('uploadStatus');
        var refreshListBtn = document.getElementById('refreshListBtn');
        var updateManifestBtn = document.getElementById('updateManifestBtn');
        var imageList = document.getElementById('imageList');

        var GITHUB_API = 'https://api.github.com';
        var IMAGES_DIR = 'images/';

        // Auto-detect repo from GitHub Pages URL
        function detectRepo() {
          try {
            var host = window.location.hostname;
            if (host.endsWith('.github.io')) {
              var parts = host.split('.');
              if (parts.length >= 2) {
                var username = parts[0];
                var pathname = window.location.pathname.split('/').filter(function(p) { return p; });
                var repoName = pathname.length > 0 ? pathname[0] : null;
                if (repoName) {
                  return username + '/' + repoName;
                }
                // If no path, repo name might be in the host
                return username + '/' + username + '.github.io';
              }
            }
          } catch(e) {}
          return null;
        }

        // Load saved settings
        function loadSettings() {
          try {
            var token = localStorage.getItem('github_token');
            var repo = localStorage.getItem('github_repo') || detectRepo();
            if (token) githubTokenInput.value = token;
            if (repo) githubRepoInput.value = repo;
          } catch(e) {}
        }

        function getToken() {
          return githubTokenInput.value.trim() || localStorage.getItem('github_token') || '';
        }

        function getRepo() {
          return githubRepoInput.value.trim() || localStorage.getItem('github_repo') || '';
        }

        function showMessage(el, msg, type) {
          el.innerHTML = '<div class="message ' + type + '">' + msg + '</div>';
          setTimeout(function() { el.innerHTML = ''; }, 5000);
        }

        // Toggle panel
        manageBtn.addEventListener('click', function() {
          managePanel.classList.toggle('open');
        });

        // Save token
        saveTokenBtn.addEventListener('click', function() {
          var token = githubTokenInput.value.trim();
          if (!token) {
            showMessage(uploadStatus, 'Please enter a token', 'error');
            return;
          }
          try {
            localStorage.setItem('github_token', token);
            showMessage(uploadStatus, 'Token saved', 'success');
          } catch(e) {
            showMessage(uploadStatus, 'Failed to save token: ' + e.message, 'error');
          }
        });

        // Save repo
        saveRepoBtn.addEventListener('click', function() {
          var repo = githubRepoInput.value.trim();
          if (!repo || repo.indexOf('/') === -1) {
            showMessage(uploadStatus, 'Please enter a valid repo (owner/repo)', 'error');
            return;
          }
          try {
            localStorage.setItem('github_repo', repo);
            showMessage(uploadStatus, 'Repository saved', 'success');
            loadImageList();
          } catch(e) {
            showMessage(uploadStatus, 'Failed to save repo: ' + e.message, 'error');
          }
        });

        // File input change
        fileInput.addEventListener('change', function() {
          uploadBtn.disabled = !this.files || this.files.length === 0;
        });

        // Upload files
        uploadBtn.addEventListener('click', function() {
          var files = fileInput.files;
          if (!files || files.length === 0) return;

          var token = getToken();
          var repo = getRepo();
          if (!token || !repo) {
            showMessage(uploadStatus, 'Please configure token and repository first', 'error');
            return;
          }

          uploadBtn.disabled = true;
          uploadBtn.textContent = 'Uploading...';
          uploadStatus.innerHTML = '<div class="message info">Uploading ' + files.length + ' file(s)...</div>';

          var uploadPromises = [];
          for (var i = 0; i < files.length; i++) {
            uploadPromises.push(uploadFile(files[i], token, repo));
          }

          Promise.all(uploadPromises).then(function(results) {
            var success = 0, failed = 0;
            for (var j = 0; j < results.length; j++) {
              if (results[j].success) success++;
              else failed++;
            }
            var msg = 'Uploaded ' + success + ' file(s)';
            if (failed > 0) msg += ', ' + failed + ' failed';
            showMessage(uploadStatus, msg, failed > 0 ? 'error' : 'success');
            fileInput.value = '';
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Upload Selected';
            if (success > 0) {
              showMessage(uploadStatus, 'Updating manifest...', 'info');
              updateManifest(token, repo).then(function() {
                showMessage(uploadStatus, 'Manifest updated! Refreshing...', 'success');
                // Wait a moment for GitHub Pages to update, then refresh
                setTimeout(function() {
                  loadImageList();
                  // Refresh the viewer with cache busting
                  if (window.refreshViewer) window.refreshViewer();
                }, 2000);
              }).catch(function(err) {
                var errMsg = err.message || 'Unknown error';
                showMessage(uploadStatus, 'Manifest update failed: ' + errMsg + '. Image uploaded but manifest not updated. Refreshing anyway...', 'error');
                console.error('Manifest update error:', err);
                // Still try to refresh - the image is there, just need to wait longer
                setTimeout(function() {
                  loadImageList();
                  if (window.refreshViewer) window.refreshViewer();
                }, 5000); // Wait longer since manifest might not be updated
              });
            }
          }).catch(function(err) {
            showMessage(uploadStatus, 'Upload error: ' + err.message, 'error');
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload Selected';
          });
        });

        function uploadFile(file, token, repo) {
          return new Promise(function(resolve) {
            var reader = new FileReader();
            reader.onload = function(e) {
              var content = e.target.result;
              var base64 = content.split(',')[1];
              var filename = file.name;
              var path = IMAGES_DIR + filename;

              // Get default branch and file SHA if exists (for update)
              getDefaultBranch(repo, token).then(function(branch) {
                return getFileSha(repo, path, token, branch).then(function(sha) {
                  var url = GITHUB_API + '/repos/' + encodeURIComponent(repo) + '/contents/' + encodeURIComponent(path);
                  var body = {
                    message: 'Add/update image: ' + filename,
                    content: base64,
                    branch: branch
                  };
                  if (sha) body.sha = sha;

                  return fetch(url, {
                    method: 'PUT',
                    headers: {
                      'Authorization': 'token ' + token,
                      'Accept': 'application/vnd.github.v3+json',
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                  }).then(function(res) {
                    if (!res.ok) {
                      return res.json().then(function(err) {
                        throw new Error(err.message || 'Upload failed');
                      });
                    }
                    return res.json();
                  }).then(function(data) {
                    resolve({success: true, filename: filename});
                  }).catch(function(err) {
                    resolve({success: false, filename: filename, error: err.message});
                  });
                });
              }).catch(function(err) {
                resolve({success: false, filename: filename, error: err.message});
              });
            };
            reader.readAsDataURL(file);
          });
        }

        function getFileSha(repo, path, token, branch) {
          var url = GITHUB_API + '/repos/' + encodeURIComponent(repo) + '/contents/' + encodeURIComponent(path);
          if (branch) url += '?ref=' + encodeURIComponent(branch);
          return fetch(url, {
            headers: {
              'Authorization': 'token ' + token,
              'Accept': 'application/vnd.github.v3+json'
            }
          }).then(function(res) {
            if (res.status === 404) return null;
            if (!res.ok) throw new Error('Failed to check file');
            return res.json().then(function(data) {
              return data.sha || null;
            });
          });
        }

        function deleteFile(filename, token, repo) {
          var path = IMAGES_DIR + filename;
          return getDefaultBranch(repo, token).then(function(branch) {
            return getFileSha(repo, path, token, branch).then(function(sha) {
              if (!sha) {
                throw new Error('File not found');
              }
              var url = GITHUB_API + '/repos/' + encodeURIComponent(repo) + '/contents/' + encodeURIComponent(path);
              return fetch(url, {
                method: 'DELETE',
                headers: {
                  'Authorization': 'token ' + token,
                  'Accept': 'application/vnd.github.v3+json',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  message: 'Delete image: ' + filename,
                  sha: sha,
                  branch: branch
                })
              }).then(function(res) {
                if (!res.ok) {
                  return res.json().then(function(err) {
                    throw new Error(err.message || 'Delete failed');
                  });
                }
                return res.json();
              });
            });
          });
        }

        function getDefaultBranch(repo, token) {
          // Try to get default branch from repo info
          return fetch(GITHUB_API + '/repos/' + encodeURIComponent(repo), {
            headers: {
              'Authorization': 'token ' + token,
              'Accept': 'application/vnd.github.v3+json'
            }
          }).then(function(res) {
            if (!res.ok) {
              console.warn('Could not get default branch, using "main"');
              return 'main'; // fallback
            }
            return res.json().then(function(data) {
              return data.default_branch || 'main';
            }).catch(function() {
              return 'main'; // fallback
            });
          }).catch(function(err) {
            console.warn('Error getting default branch:', err, '- using "main"');
            return 'main'; // fallback
          });
        }

        function updateManifest(token, repo) {
          // Get default branch first
          return getDefaultBranch(repo, token).then(function(branch) {
            // Get all files from repo (specify branch)
            // Remove trailing slash for GitHub API
            var imagesPath = IMAGES_DIR.replace(/\/$/, '');
            var url = GITHUB_API + '/repos/' + encodeURIComponent(repo) + '/contents/' + encodeURIComponent(imagesPath) + '?ref=' + encodeURIComponent(branch);
            console.log('Fetching files from:', url);
            return fetch(url, {
              headers: {
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
              }
            }).then(function(res) {
              if (!res.ok) {
                return res.json().then(function(err) {
                  throw new Error('Failed to list files: ' + (err.message || 'HTTP ' + res.status));
                }).catch(function() {
                  throw new Error('Failed to list files: HTTP ' + res.status);
                });
              }
              return res.json();
            }).catch(function(err) {
              console.error('Error listing files:', err);
              throw new Error('Network error listing files: ' + (err.message || 'Unknown error'));
            }).then(function(files) {
              var images = [];
              var supportedExt = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
              for (var i = 0; i < files.length; i++) {
                var name = files[i].name.toLowerCase();
                if (files[i].type === 'file' && files[i].name.toLowerCase() !== 'manifest.json') {
                  for (var j = 0; j < supportedExt.length; j++) {
                    if (name.endsWith(supportedExt[j])) {
                      images.push(files[i].name);
                      break;
                    }
                  }
                }
              }
              images.sort();

              var manifestData = {
                generatedAt: new Date().toISOString(),
                count: images.length,
                images: images
              };

              var manifestPath = IMAGES_DIR + 'manifest.json';
              var content = JSON.stringify(manifestData, null, 2) + '\n';
              var base64 = btoa(unescape(encodeURIComponent(content)));

              return getFileSha(repo, manifestPath, token, branch).then(function(sha) {
                var url = GITHUB_API + '/repos/' + encodeURIComponent(repo) + '/contents/' + encodeURIComponent(manifestPath);
                var body = {
                  message: 'Update manifest.json',
                  content: base64,
                  branch: branch
                };
                if (sha) body.sha = sha;

                return fetch(url, {
                  method: 'PUT',
                  headers: {
                    'Authorization': 'token ' + token,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(body)
                }).then(function(res) {
                  if (!res.ok) {
                    return res.json().then(function(err) {
                      throw new Error(err.message || 'Update failed: HTTP ' + res.status);
                    }).catch(function() {
                      throw new Error('Update failed: HTTP ' + res.status);
                    });
                  }
                  return res.json();
                }).catch(function(err) {
                  console.error('Error updating manifest:', err);
                  throw new Error('Network error updating manifest: ' + (err.message || 'Unknown error'));
                });
              }).catch(function(err) {
                console.error('Error getting file SHA:', err);
                throw err;
              });
            }).catch(function(err) {
              console.error('Error processing files:', err);
              throw err;
            });
          }).catch(function(err) {
            console.error('Error in updateManifest:', err);
            throw err;
          });
        }

        function loadImageList() {
          var token = getToken();
          var repo = getRepo();
          if (!token || !repo) {
            imageList.innerHTML = '<div class="message info">Configure token and repository to view images</div>';
            return;
          }

          imageList.innerHTML = '<div class="message info">Loading...</div>';

          // Add cache busting timestamp
          var cacheBuster = '?t=' + Date.now();
          fetch(IMAGES_DIR + 'manifest.json' + cacheBuster, {cache: 'no-store'})
            .then(function(res) {
              if (!res.ok) throw new Error('Failed to load manifest');
              return res.json();
            })
            .then(function(manifest) {
              var images = manifest.images || [];
              if (images.length === 0) {
                imageList.innerHTML = '<div class="message info">No images found</div>';
                return;
              }

              imageList.innerHTML = '';
              for (var i = 0; i < images.length; i++) {
                var imgName = images[i];
                var imgUrl = IMAGES_DIR + imgName;
                var item = document.createElement('div');
                item.className = 'image-item';
                item.innerHTML = 
                  '<img src="' + imgUrl + '" alt="' + imgName + '" onerror="this.style.display=\'none\'" />' +
                  '<div class="info">' +
                    '<div class="name">' + imgName + '</div>' +
                    '<div class="size">Image ' + (i + 1) + ' of ' + images.length + '</div>' +
                  '</div>' +
                  '<button class="danger" data-filename="' + imgName + '">Delete</button>';
                imageList.appendChild(item);
              }

              // Attach delete handlers
              var deleteBtns = imageList.querySelectorAll('button.danger');
              for (var j = 0; j < deleteBtns.length; j++) {
                deleteBtns[j].addEventListener('click', function() {
                  var filename = this.getAttribute('data-filename');
                  if (!confirm('Delete ' + filename + '?')) return;

                  this.disabled = true;
                  this.textContent = 'Deleting...';
                  deleteFile(filename, token, repo).then(function() {
                    showMessage(uploadStatus, 'Deleted ' + filename + '. Updating manifest...', 'success');
                    updateManifest(token, repo).then(function() {
                      showMessage(uploadStatus, 'Manifest updated! Refreshing...', 'success');
                      // Wait a moment for GitHub Pages to update
                      setTimeout(function() {
                        loadImageList();
                        // Refresh the viewer
                        if (window.refreshViewer) window.refreshViewer();
                      }, 2000);
                    }).catch(function(err) {
                      showMessage(uploadStatus, 'Manifest update failed: ' + err.message + '. You may need to refresh manually.', 'error');
                      console.error('Manifest update error:', err);
                      setTimeout(function() {
                        loadImageList();
                        if (window.refreshViewer) window.refreshViewer();
                      }, 2000);
                    });
                  }).catch(function(err) {
                    showMessage(uploadStatus, 'Delete failed: ' + err.message, 'error');
                    this.disabled = false;
                    this.textContent = 'Delete';
                  }.bind(this));
                });
              }
            })
            .catch(function(err) {
              imageList.innerHTML = '<div class="message error">Failed to load images: ' + err.message + '</div>';
            });
        }

        refreshListBtn.addEventListener('click', loadImageList);

        // Manual manifest update button
        updateManifestBtn.addEventListener('click', function() {
          var token = getToken();
          var repo = getRepo();
          if (!token || !repo) {
            showMessage(uploadStatus, 'Please configure token and repository first', 'error');
            return;
          }
          this.disabled = true;
          this.textContent = 'Updating...';
          showMessage(uploadStatus, 'Updating manifest...', 'info');
          updateManifest(token, repo).then(function() {
            showMessage(uploadStatus, 'Manifest updated successfully!', 'success');
            setTimeout(function() {
              loadImageList();
              if (window.refreshViewer) window.refreshViewer();
            }, 2000);
          }).catch(function(err) {
            var errMsg = err.message || 'Unknown error';
            showMessage(uploadStatus, 'Failed: ' + errMsg + '. Check console for details.', 'error');
            console.error('Manual manifest update error:', err);
          }).finally(function() {
            updateManifestBtn.disabled = false;
            updateManifestBtn.textContent = 'Update Manifest';
          });
        });

        // Initialize
        loadSettings();
        loadImageList();
      })();
    </script>
    <noscript>JavaScript is required to run the slideshow.</noscript>
  </body>
  </html>
